---
title: "Using nest when working on trips"
author: Einar Hj√∂rleifsson
description: "The eflalo data-format that is used as a starting point in the ices datacall guidelines is not tidy. Hence when e.g. trying to deal with issues in the trip registration, like time overlaps, one can end up with some cumbersome coding sequence. Here an attempt is made to use the `nest` feature with the objective of simplifying the code."
date: "2025-02-28"
categories: [code, rtip]
---

**NEED TO REVISIT THIS**

## Eflalo format

The eflalo data-format that is used as a starting point in the ices datacall guidelines are kind of a mixture of:

* Vessel data records
* Trip data records
* Detail records. These could be:
  * Single catch records per day by statistical rectangle
  * Catch records by individual settings/tows
  * Something else that I am not aware of, because of lack of expertise

This means that the vessel records and trip records are repeated as many time there are detail records. This structure do not fall under the definition of [tidy data](https://r4ds.hadley.nz/data-tidy.html#sec-tidy-data), a byproduct being that coding, at least in the tidyverse, can sometimes be a bit cumbersome.

There are two ways around this:

* Split the eflalo table into vessel table, trip table and detail table
* Keep the objects together and split thing up using the `nest`-process

When dealing with the issue of "Remove trip with overlap with another trip" the latter is attempted here using the eflalo data in {vmstools}. Prior attempts in earlier post dealt only with synthetic data.

First we do some minimal transformations on trip departure and arrival time.

```{r}
library(vmstools)
library(tidyverse)
data("eflalo")
eflalo <- 
  eflalo |> 
  as_tibble() |> 
  dplyr::mutate(FT_DDAT = stringr::str_replace(FT_DDAT, "1800", "1803"),
                FT_DDAT = stringr::str_replace(FT_DDAT, "1801", "1804"),
                FT_LDAT = stringr::str_replace(FT_LDAT, "1800", "1803"),
                FT_LDAT = stringr::str_replace(FT_LDAT, "1801", "1804"),
                LE_CDAT = stringr::str_replace(LE_CDAT, "1800", "1803"),
                LE_CDAT = stringr::str_replace(LE_CDAT, "1801", "1804")) |> 
  unite(col = "FT_DDATIM", FT_DDAT, FT_DTIME) |> 
  unite(col = "FT_LDATIM", FT_LDAT, FT_LTIME) |> 
  mutate(FT_DDATIM = dmy_hms(FT_DDATIM),
         FT_LDATIM = dmy_hms(FT_LDATIM))
```

Take note that the eflalo has `r nrow(eflalo)` records. In the next step we do:

* Properly arrange the data by vessel id and time
* Nest all data except vessel and (critical) trip records
* Classify consecutive trips with respect to time (not necessarily exhaustive)

```{r}
eflalo1 <- 
  eflalo |> 
  arrange(VE_COU, VE_REF, FT_DDATIM) |> 
  nest(.by = VE_REF:FT_LDATIM)
eflalo1 |> glimpse()
```

So basically we have now `r nrow(eflalo)` records where all the detail records within a trip have been "collapsed" within the "data" table.

```{r}
eflalo1 <- 
  eflalo1 |> 
  group_by(VE_COU, VE_REF) |> 
  mutate(issues = 
           case_when(
                     FT_DDATIM > FT_LDATIM ~ "arrival before departure",
                     FT_DDATIM == FT_LDATIM ~ "arrival same as departure",
                     FT_LDATIM > lead(FT_DDATIM) ~ "next departure before current arrival",
                     lag(FT_LDATIM) > FT_DDATIM ~ "previous arrival after current departure",
                     row_number() == 1 ~ "0_first row in a group", 
                     row_number() == max(row_number()) ~ "0_last row in a group",
                     .default = "0_no issues")) |> 
  ungroup()
```

In the dataset that comes with {vmstools} we get the following issues:

```{r}
eflalo1 |> count(issues)
```

Let's check the overlaps:

```{r}
eflalo1 |> 
  filter(issues %in% c("next departure before current arrival",
                       "previous arrival after current departure")) |> 
  select(VE_REF, VE_FLT, FT_REF, FT_DHAR:FT_DDATIM, FT_LHAR, FT_LDATIM, issues) |> 
  knitr::kable()
```

So issues are raised in cases where we have multiple gear within a trip. There are three remedies:

1. Include the VE_FLT within the listed data
2. Add VE_FLT to the grouping, but not change the "issue" code
3. Keep the grouping but try to ameliorate the case_when coding for "issues" - possibly the least 

To demonstrate using the first option one could do something like the following:

```{r}
eflalo2.1 <- 
  eflalo |> 
  arrange(VE_COU, VE_REF, FT_DDATIM) |> 
  nest(.by = c(VE_REF, VE_COU:FT_LDATIM)) |> # Change things here
  group_by(VE_COU, VE_REF) |> 
  mutate(issues = 
           case_when(
                     FT_DDATIM > FT_LDATIM ~ "arrival before departure",
                     FT_DDATIM == FT_LDATIM ~ "arrival same as departure",
                     FT_LDATIM > lead(FT_DDATIM) ~ "next departure before current arrival",
                     lag(FT_LDATIM) > FT_DDATIM ~ "previous arrival after current departure",
                     row_number() == 1 ~ "0_first row in a group", 
                     row_number() == max(row_number()) ~ "0_last row in a group",
                     .default = "0_no issues")) |> 
  ungroup()
eflalo2.1 |> count(issues)
```

To demonstrate using the second option one could do something like the following:

```{r}
eflalo2.2 <- 
  eflalo |> 
  arrange(VE_COU, VE_REF, FT_DDATIM) |> 
  nest(.by = c(VE_REF:FT_LDATIM)) |> 
  group_by(VE_COU, VE_REF, VE_FLT) |>    # Change things here
  mutate(issues = 
           case_when(
                     FT_DDATIM > FT_LDATIM ~ "arrival before departure",
                     FT_DDATIM == FT_LDATIM ~ "arrival same as departure",
                     FT_LDATIM > lead(FT_DDATIM) ~ "next departure before current arrival",
                     lag(FT_LDATIM) > FT_DDATIM ~ "previous arrival after current departure",
                     row_number() == 1 ~ "0_first row in a group", 
                     row_number() == max(row_number()) ~ "0_last row in a group",
                     .default = "0_no issues")) |> 
  ungroup()
eflalo2.2 |> count(issues)
```

So there is only one record were we have an issue. Let's filter it out and then "explode" the data-set again:

```{r}
eflalo2.2 |> 
  filter(str_starts(issues, "0_")) |> 
  unnest(data)
```

Note that the code above only tests for time issues of adjacent trips. So one may actually have to repeat the process to ensure that no further time overlap issues are present.

As a last note I must say I find it confusing that VE_FLT is specified at the vessel level. Would be more comprehensible if this was labelled as LE_FLT. But then again the intricacies of how things are done down south are a bit alien to us goonies in the north.

## Test on Icelandic data

Just to complete this with a little test on Icelandic data. We emulate the eflalo structure by joining the trips with the individual setting records (thus exploding the trip table):

```{r}
library(omar)
con <- connect_mar()
tbl_mar(con, "adb.trip_v") |> 
  filter(year(departure) == 2025) |> 
  select(trip_id, 
         vid = vessel_no,
         T1 = departure,
         hid1 = departure_port_no,
         T2 = landing,
         hid2 = landing_port_no,
         source) |> 
  # only trips were some logbook recorded
  inner_join(tbl_mar(con, "adb.station_v") |> 
              select(trip_id,
                     station_id,
                     gid = gear_no,
                     t1 = fishing_start,
                     t2 = fishing_end,
                     lon1 = longitude,
                     lat1 = latitude,
                     lon2 = longitude_end,
                     lat2 = latitude_end,
                     z1 = depth,
                     z2 = depth_end),
            by = join_by(trip_id)) |> 
  collect(n = Inf) ->
  trips_and_tows
```

The structure of the data looks something like this:

```{r}
trips_and_tows |> glimpse()
```

The variable names here are a bit different from the eflalo standards but one should be able to glean it from the code. The followed up step are the same, we only have different names for the variables:

```{r}
trips_and_tows <- 
  trips_and_tows |> 
  arrange(vid, T1, T2) |> 
  nest(.by = c(vid, trip_id, T1, T2)) |> 
  group_by(vid) |> 
  mutate(issues = 
           case_when(
             T1 > T2 ~ "arrival before departure",
             T1 == T2 ~ "arrival same as departure",
             T2 > lead(T1) ~ "next departure before current arrival",
             lag(T2) > T1 ~ "previous arrival after current departure",
             row_number() == 1 ~ "0_first row in a group", 
             row_number() == max(row_number()) ~ "0_last row in a group",
             .default = "0_no issues")) |> 
  ungroup()

trips_and_tows |> count(issues) |> mutate(p = round(n / sum(n), 3))
```

There are some decisions to be made with the coding and this dataset before proceeding, but that is outside the scope of these notes.
